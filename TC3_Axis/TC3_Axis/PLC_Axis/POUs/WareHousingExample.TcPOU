<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="WareHousingExample" Id="{0e6956dd-ffba-455e-80e5-cadd31dc7a91}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM WareHousingExample
VAR
//		Axis_X : itfAxis;
//		Axis_Y : itfAxis;
//		Axis_Z : itfAxis;
//		stateOOP : INT;
//		lastCommandX : itfCommand;
//		lastCommandY : itfCommand;
//		lastCommandZ : itfCommand;
//		stepOn : BOOL := FALSE;
//		targetPosX : REAL := 400;
//		targetPosY : REAL := 600;
		stateOOP : INT;
		stepOn : BOOL := FALSE;

		AXIS_REF_X 			: Tc2_MC2.AXIS_REF;
		AXIS_REF_Y 			: Tc2_MC2.AXIS_REF;
		AXIS_REF_Z 			: Tc2_MC2.AXIS_REF;
		AXIS_REF_X_Slave 	: Tc2_MC2.AXIS_REF;
		
		fbAxis_X : TcAxis_Tc2_MC2;
		fbAxis_Y : TcAxis_Tc2_MC2;
		fbAxis_Z : TcAxis_Tc2_MC2;
		fbAxis_X_Slave : TcAxis_Tc2_MC2;

		Axis_X : itfAxis;
		Axis_Y : itfAxis;
		Axis_Z : itfAxis;
		Axis_X_Slave : itfAxis;
		
		lastCommandX : itfCommand;
		lastCommandY : itfCommand;
		lastCommandZ : itfCommand;
		
		targetPosX : REAL := 400;
		targetPosY : REAL := 600;
		
		ActualPosition_X : REAL;
		ActualPosition_Y : REAL;
		ActualPosition_Z : REAL;
		
		ActualVelocity_X : REAL;
		ActualVelocity_Y : REAL;
		ActualVelocity_Z : REAL;
		
		ActualTorque_X : REAL;
		ActualTorque_Y : REAL;
		ActualTorque_Z : REAL;
				
		fbGear_X_Slave : Tc2_MC2.MC_GearIn;
		
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
fbAxis_X(Axis:=AXIS_REF_X);
fbAxis_Y(Axis:=AXIS_REF_Y);
fbAxis_Z(Axis:=AXIS_REF_Z);
fbAxis_X_Slave(Axis:=AXIS_REF_X_Slave);

Axis_X := fbAxis_X;
Axis_Y := fbAxis_Y;
Axis_Z := fbAxis_Z;
Axis_X_Slave := fbAxis_X_Slave;

// !!! see if creating a method, because with the property it says: "has no effect,. Is this the intent!!!
//Axis_X.MotionStatus;
//Axis_Y.MotionStatus;
//Axis_Z.MotionStatus;

ActualPosition_x := Axis_X.ActualPosition;
ActualPosition_Y := Axis_Y.ActualPosition;
ActualPosition_Z := Axis_Z.ActualPosition;

ActualVelocity_x := Axis_X.ActualVelocity;
ActualVelocity_Y := Axis_Y.ActualVelocity;
ActualVelocity_Z := Axis_Z.ActualVelocity;

ActualTorque_x := Axis_X.ActualTorque;
ActualTorque_Y := Axis_Y.ActualTorque;
ActualTorque_Z := Axis_Z.ActualTorque;

CASE stateOOP OF
	0: ;
	10: 
	// init
		Axis_X.Power(Enable:=TRUE, EnablePositive:=TRUE, EnableNegative:=TRUE);
		Axis_Y.Power(Enable:=TRUE, EnablePositive:=TRUE, EnableNegative:=TRUE);
		Axis_Z.Power(Enable:=TRUE, EnablePositive:=TRUE, EnableNegative:=TRUE);
		Axis_X_Slave.Power(Enable:=TRUE, EnablePositive:=TRUE, EnableNegative:=TRUE);
	
		IF stepOn THEN
			stateOOP := 11;		
			stepOn := FALSE;
		END_IF
		
	11 : 
	//GearIn
		//Axis_X_Slave.GearIn(Master:= AXIS_REF_X,Slave:= AXIS_REF_X_Slave, RatioNumerator:= 1,RatioDenominator:= 1, Acceleration:= 0,Deceleration:= 0, Jerk:= 0,BufferMode:= MC_BUFFER_MODE.mcAborting);
		//Axis_X.GearIn(Slave:= AXIS_REF_X_Slave, RatioNumerator:= 1,RatioDenominator:= 1, Acceleration:= 0,Deceleration:= 0, Jerk:= 0,BufferMode:= MC_BUFFER_MODE.mcAborting);
		fbAxis_X.GearIn(Master:= AXIS_REF_X,Slave:= AXIS_REF_X_Slave, RatioNumerator:= 1,RatioDenominator:= 1, Acceleration:= 0,Deceleration:= 0, Jerk:= 0,BufferMode:= MC_BUFFER_MODE.mcBuffered);
		
//		fbGear_X_Slave(
//			Master:=AXIS_REF_X, 
//			Slave:= AXIS_REF_X_Slave, 
//			Execute:= TRUE, 
//			RatioNumerator:= 1, 
//			RatioDenominator:= 1, 
//			Acceleration:= ,//Acceleration, 
//			Deceleration:= ,//Deceleration, 
//			Jerk:= ,//Jerk, 
//			BufferMode:= ,//BufferMode,//BufferMode, 
//			Options:= ,//Options, 
//			InGear=> , 
//			Busy=> , 
//			Active=> , 
//			CommandAborted=> , 
//			Error=> , 
//			ErrorID=> );
				
		IF stepOn THEN
			stateOOP := 20;		
			stepOn := FALSE;
		END_IF
	20:
	// start movement in XY
		lastCommandX := Axis_X.MoveAbsolute(Position:=targetPosX, Velocity:=40, Acceleration:=0, Deceleration:=0, Jerk:=0, Direction:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
		lastCommandY := Axis_Y.MoveAbsolute(Position:=targetPosY, Velocity:=40, Acceleration:=0, Deceleration:=0, Jerk:=0, Direction:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
		
		IF stepOn THEN
		stateOOP := stateOOP + 10;
		END_IF
	30:
	// wait till movement is finished to 'forkIn'
		IF lastCommandX.Done AND lastCommandY.Done THEN
			lastCommandZ := Axis_Z.MoveRelative(Distance:=100, Velocity:=20, Acceleration:=0, Deceleration:=0, Jerk:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
			stateOOP := stateOOP + 10;
		END_IF
	40:
	// lift pallet if forked in
		IF lastCommandZ.Done THEN
			lastCommandY := Axis_Y.MoveRelative(Distance:=100, Velocity:=10, Acceleration:=0, Deceleration:=0, Jerk:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
			stateOOP := stateOOP + 10;
		END_IF
	50:
	// fork out with pallet if forked in is done
		IF lastCommandY.Done THEN
			lastCommandZ := Axis_Z.MoveAbsolute(Position:=0, Velocity:=20, Acceleration:=0, Deceleration:=0, Jerk:=0, Direction:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
			stateOOP := stateOOP + 10;
		END_IF
	60:
	// move to delivery if fork out is done
		IF lastCommandZ.Done THEN
			lastCommandX := Axis_X.MoveAbsolute(Position:=0, Velocity:=40, Acceleration:=0, Deceleration:=0, Jerk:=0, Direction:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
			lastCommandY := Axis_Y.MoveAbsolute(Position:=0, Velocity:=40, Acceleration:=0, Deceleration:=0, Jerk:=0, Direction:=0, BufferMode:=MC_BUFFER_MODE.mcAborting);
			stateOOP := stateOOP + 10;
		END_IF
	70:
	// wait till finished
		IF lastCommandX.Done AND lastCommandY.Done THEN
			stateOOP := stateOOP + 10;
		END_IF
	80: 
	// ready
	;
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>